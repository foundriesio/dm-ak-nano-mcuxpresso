# Aktualizr-nano client for MCUXpresso SDK

PoC code for a Foundries.io OTA client (Aktualizr-nano) running on top of MCUXpresso SDK

## Prerequisites

- gcc-arm-none-eabi-10.3-2021.10, or compatible

- cmake

- DHCP enabled local network with Internet access

The instructions assume a **MIMXRT1060-EVK** board is being used, and the development
environment is a Linux system.

# Installation instructions

## Fetching code

~~~
west init -m https://github.com/foundriesio/dm-ak-nano-mcuxpresso-manifest.git
west update
~~~

## Preparation
- Plug the RT1060 board on the PC serial (board **J1** plug)

- Start with an empty board, erasing original content if needed:

~~~
pyocd erase --mass
~~~

## MCUBoot flashing

- Get MCUBoot from MCUXPresso 2.12 + patched for DIRECT_XIP

- Make sure the *boards/evkmimxrt1060/mcuboot_opensource/secure/sign-rsa2048-pub.c*  matches *middleware/mcuboot_opensource/root-rsa-2048.pem*. Typically sign-rsa2048-pub.c needs to be updated with the content bellow:

~~~
/* Autogenerated by imgtool.py, do not edit. */
const unsigned char rsa_pub_key[] = {
    0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
    0x00, 0xd1, 0x06, 0x08, 0x1a, 0x18, 0x44, 0x2c,
    0x18, 0xe8, 0xfb, 0xfd, 0xf7, 0x0d, 0xa3, 0x4f,
    0x1f, 0xbb, 0xee, 0x5e, 0xf9, 0xaa, 0xd2, 0x4b,
    0x18, 0xd3, 0x5a, 0xe9, 0x6d, 0x18, 0x80, 0x19,
    0xf9, 0xf0, 0x9c, 0x34, 0x1b, 0xcb, 0xf3, 0xbc,
    0x74, 0xdb, 0x42, 0xe7, 0x8c, 0x7f, 0x10, 0x53,
    0x7e, 0x43, 0x5e, 0x0d, 0x57, 0x2c, 0x44, 0xd1,
    0x67, 0x08, 0x0f, 0x0d, 0xbb, 0x5c, 0xee, 0xec,
    0xb3, 0x99, 0xdf, 0xe0, 0x4d, 0x84, 0x0b, 0xaa,
    0x77, 0x41, 0x60, 0xed, 0x15, 0x28, 0x49, 0xa7,
    0x01, 0xb4, 0x3c, 0x10, 0xe6, 0x69, 0x8c, 0x2f,
    0x5f, 0xac, 0x41, 0x4d, 0x9e, 0x5c, 0x14, 0xdf,
    0xf2, 0xf8, 0xcf, 0x3d, 0x1e, 0x6f, 0xe7, 0x5b,
    0xba, 0xb4, 0xa9, 0xc8, 0x88, 0x7e, 0x47, 0x3c,
    0x94, 0xc3, 0x77, 0x67, 0x54, 0x4b, 0xaa, 0x8d,
    0x38, 0x35, 0xca, 0x62, 0x61, 0x7e, 0xb7, 0xe1,
    0x15, 0xdb, 0x77, 0x73, 0xd4, 0xbe, 0x7b, 0x72,
    0x21, 0x89, 0x69, 0x24, 0xfb, 0xf8, 0x65, 0x6e,
    0x64, 0x3e, 0xc8, 0x0e, 0xd7, 0x85, 0xd5, 0x5c,
    0x4a, 0xe4, 0x53, 0x0d, 0x2f, 0xff, 0xb7, 0xfd,
    0xf3, 0x13, 0x39, 0x83, 0x3f, 0xa3, 0xae, 0xd2,
    0x0f, 0xa7, 0x6a, 0x9d, 0xf9, 0xfe, 0xb8, 0xce,
    0xfa, 0x2a, 0xbe, 0xaf, 0xb8, 0xe0, 0xfa, 0x82,
    0x37, 0x54, 0xf4, 0x3e, 0xe1, 0x2b, 0xd0, 0xd3,
    0x08, 0x58, 0x18, 0xf6, 0x5e, 0x4c, 0xc8, 0x88,
    0x81, 0x31, 0xad, 0x5f, 0xb0, 0x82, 0x17, 0xf2,
    0x8a, 0x69, 0x27, 0x23, 0xf3, 0xab, 0x87, 0x3e,
    0x93, 0x1a, 0x1d, 0xfe, 0xe8, 0xf8, 0x1a, 0x24,
    0x66, 0x59, 0xf8, 0x1c, 0xab, 0xdc, 0xce, 0x68,
    0x1b, 0x66, 0x64, 0x35, 0xec, 0xfa, 0x0d, 0x11,
    0x9d, 0xaf, 0x5c, 0x3a, 0xa7, 0xd1, 0x67, 0xc6,
    0x47, 0xef, 0xb1, 0x4b, 0x2c, 0x62, 0xe1, 0xd1,
    0xc9, 0x02, 0x03, 0x01, 0x00, 0x01,
};
const unsigned int rsa_pub_key_len = 270;
~~~

Example (unchanged) root-rsa-2048.pem:
~~~
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEA0QYIGhhELBjo+/33DaNPH7vuXvmq0ksY01rpbRiAGfnwnDQb
y/O8dNtC54x/EFN+Q14NVyxE0WcIDw27XO7ss5nf4E2EC6p3QWDtFShJpwG0PBDm
aYwvX6xBTZ5cFN/y+M89Hm/nW7q0qciIfkc8lMN3Z1RLqo04NcpiYX634RXbd3PU
vntyIYlpJPv4ZW5kPsgO14XVXErkUw0v/7f98xM5gz+jrtIPp2qd+f64zvoqvq+4
4PqCN1T0PuEr0NMIWBj2XkzIiIExrV+wghfyimknI/Orhz6TGh3+6PgaJGZZ+Byr
3M5oG2ZkNez6DRGdr1w6p9FnxkfvsUssYuHRyQIDAQABAoIBAEahFCHFK1v/OtLT
eSSZl0Xw2dYr5QXULFpWsOOVUMv2QdB2ZyIehQKziEL3nYPlwpd+82EOa16awwVb
LYF0lnUFvLltV/4dJtjnqJTqnSCamc1mJIVrwiJA8XwJ07GWDuL2G//p7jJ3v05T
nZOV/KmD9xfqSvshZun+LgolqHqcrAa1f4cmuP9C9oqenZryljyfj7piaIZGI0JR
PrJJ5kImYJqRcMgKTyHP4L8nwQ4moMJr6zbfbWxxb5TC7KVZSQ9UKZZ+ZLuy/pkU
Qe4G8XSE0r+R9u4JCg87I1vgHhn8WJSxVX027OVUq5HfOzg2skQBTcExph5V9B2b
onNxd8UCgYEA/32PW+ZwRcdKXMj+QVkxXUd6xkXy7mTXPEaQuOLWZQgrSqAFH1l4
5/6d099KAJrjM6kR8pKXtz72IIyMHTPm332ghymjKvaEl2XP9sF+f6FmYURar4y6
8Zh3eivP86+Q/YzOGKwtRSziBMzrAfoIXgtwH8pwIPYLP3zBV4449ZsCgYEA0XC/
gu2ub5M6EXBnjq9K2d4LlTyAPsIbAcMSwkhOUH4YJFS22qXLYQUA9zM+DUyLCrl/
PKN2G0HQVgMb4DIbeHv8kXB5oGm5zfbWorWqOomXB3AsI7X8YDMtf/PsZV2amBei
qVskmPJQV21qFyeOcHlT+dHuRb0O0un3dK8RHmsCgYEApDCH4dJ80osZoflVVJ/C
VqTqJOOtFEFgBQ+AUCEPEQyn7aRaxmPUjJsXyKJVx3/ChV+g9hf5Qj1HJXHNVbMW
KwhsEpDSmHimizlV5clBxzntNpMcCHdTaJHILo5bbMqmThugE0ELMsp+UgFzAeky
WWXWX8fUOYqFff5prh/rQQMCgYBQQ8FhT+113Rp37HgDerJY5HvT6afMZV8sQbJC
uqsotepSohShnsBeoihIlF7HgfoXVhepCYwNzh8ll3NrbEiS2BFnO4+hJmOKx3pi
SPTAElLLCvYfiXL6+yII01ZZUpIYj5ZLCR7xbovTtZ7e2M4B1L2WFBoYp+eydO/c
y+rnmQKBgCh0gfyBT/OKPkfKv+Bbt8HcoxgEj+TyH+vYdeTbP9ZSJ6y5utMbPg7z
iLLbJ+9IcSwPCwJSmI+I0Om4xEp4ZblCrzAG7hWvG2NNzxQjmoOOrAANyTvJR/ap
N+UkQA4WrMSKEYyBlRS/hR9Unz31vMc2k9Re0ukWhWh/QksQGDfJ
-----END RSA PRIVATE KEY-----
~~~

- Build MCUBoot
~~~
cd ~/nxp_sdk/SDK_2_12_0_EVK-MIMXRT1060/boards/evkmimxrt1060/mcuboot_opensource/armgcc

./build_flexspi_nor_debug.sh
~~~

- Load resulting elf image into board
~~~
pyocd load flexspi_nor_debug/mcuboot_opensource.elf
~~~

## Image trailer for slot 1

* The trailer information is updated during the OTA update process, but we need to
write it manually for the first boot to succeed. Run:

~~~
dd if=/dev/zero of=image_trailer.bin bs=1 count=216

# swap_type
dd if=/dev/zero bs=1 count=8 >> image_trailer.bin

# copy_done
echo -n $'\x01' >> image_trailer.bin
dd if=/dev/zero bs=1 count=7 >> image_trailer.bin

# image_ok
echo -n $'\x01' >> image_trailer.bin
dd if=/dev/zero bs=1 count=7 >> image_trailer.bin

# magic
echo -n $'\x77\xc2\x95\xf3' >> image_trailer.bin
echo -n $'\x60\xd2\xef\x7f' >> image_trailer.bin
echo -n $'\x35\x52\x50\x0f' >> image_trailer.bin
echo -n $'\x2c\xb6\x79\x80' >> image_trailer.bin

pyocd load image_trailer.bin -a 0x6023ff00
~~~

## Device keys and certificate provisioning

Provisioning of device keys and certificates is done by a separate application,
hosted at https://github.com/foundriesio/dm-ak-nano-mcuxpresso-provisioning/

It can be built on top of MCUXpresso SDK 2.11, after filling the CA keys information
in aknano_secret.h.

After building and signing the provisioning firmware, it should be loaded to the 
board:
~~~
pyocd flash provisioning_fw_rt1060.bin -a 0x60040000
~~~

Provisioning of keys is application specific, and is likelly to change during the next
development phase. It does not require the board to be connected to the network.

After running the provisioning app once, the main application can be loded.


## Building, signing and flashing main application

First, fill the factory information in aknano_secret.h (AKNANO_*).

The main application can be build using an auxiliary build script, build_sign_publish.sh,
that signs the resulting binary, and performs the flashing operation. 

Before running the script, the following cross-compiling paths need to be set: 
~~~
export PATH=$PATH:~/toolchains/gcc-arm-none-eabi-10.3-2021.10/bin
export ARMGCC_DIR=~/toolchains/gcc-arm-none-eabi-10.3-2021.10
~~~

The path to a MCUBoot also has to be set, and is used to find the imgtool.py
script and the root-rsa-2048.pem file used during the signing process. 
~~~
export MCUBOOT_PATH=~/nxp_sdk/SDK_2_11_1_MIMXRT1170-EVK/middleware/mcuboot_opensource/
~~~
The script might as well be adjusted manually to use these files from hardcoded
places.


Finally, the build script can be called.
~~~
cd foundriesio/dm-ak-nano-mcuxpresso/armgcc
# build for RT1060, do not publish fw, flash slot 1
./build_sign_publish.sh --rt1060 -P -f1
~~~
After flashing this step, the board will reboot and start executing the PoC application.
Make sure the network cable is connected to the board. The device will register itself
in the factory, and will proceed polling the update server trying to fetch updates.


## Publishing new versions

To generate new versions to test the OTA functionality, an yet unreleased version
of fioctl is required. It can be fetched from: https://github.com/foundriesio/fioctl/tree/mcu-api.
Notice that the feature is only available in the mcu-api branch.

After compiling fioctl, set its path:
~~~
export FIOCTL_PATH=~/git_foundries/fioctl/bin"
~~~

Make sure to `fioctl login` using your client ID, which must have access to the
factory.

Then, the application can be built and published:

~~~
# build for RT1060, publish, do not flash
./build_sign_publish.sh --rt1060
~~~
